#!/usr/bin/python
import datetime
import pydsm
import argparse
import re
import string
import StringIO
import sys
import subprocess
import email.mime.text

today = datetime.datetime.now().date()

yesterday = today - datetime.timedelta(1)

errors_events=False
errors_actlog=False

# parse arguments

parser = argparse.ArgumentParser(description='Display TSM backup history')
parser.add_argument('--server', dest="server",
                   help='TSM server to connect to')
parser.add_argument('--format', dest="format",
                   choices=["readable", "csv"], default="readable",
                   help='format to use when displaying results')
parser.add_argument('--date', dest="date",
                   help='Date of report')
parser.add_argument('--sender', dest="sender", required=True,
                   help='Sender email address')
parser.add_argument('--email', dest="email", required=True,
                   help='Destination email address')
parser.add_argument("--debug", help="write email to stdout instead of sending it",
                    action="store_true")


args = parser.parse_args()

if args.date is None:
    start = datetime.datetime.combine(yesterday, datetime.time(8,30))
else:
    dt = datetime.datetime.strptime(args.date, "%Y-%m-%d").date()
    start = datetime.datetime.combine(dt, datetime.time(8,30))
stop = datetime.datetime.combine(start + datetime.timedelta(days=1), datetime.time(8,30))

s = StringIO.StringIO()
f = pydsm.get_formatter(args.format, output=s)

def header(name):
    l = len(name)
    f.write("\n\n%s\n* %s *\n%s\n"%("*"*(l+4),name.upper(),"*"*(l+4)))

def message_handler(msg_prefix, msg_number, msg_type, msg_text):
    f.write("%s%s%s %s\n"%(msg_prefix, msg_number, msg_type, msg_text))

d = pydsm.dsmadmc()
d.set_message_handler(message_handler)
d.auto_open(args.server)


f.write("TSM summary from %s to %s\n\n"%(start,stop))

# ---------------  EVENTS -------------------

header("events")

results = d.execute(
"""select
    date(SCHEDULED_START),
    time(SCHEDULED_START),
    time(ACTUAL_START),
    time(COMPLETED),
    DOMAIN_NAME,
    SCHEDULE_NAME,
    NODE_NAME,
    STATUS,
    RESULT
from events
where SCHEDULED_START >= %s and SCHEDULED_START < %s
order by SCHEDULED_START
""", (start, stop))

headers = [
    { "name": "Date", },
    { "name": "Scheduled", },
    { "name": "Start", },
    { "name": "Completed", },
    { "name": "Domain", },
    { "name": "Schedule", },
    { "name": "Node", },
    { "name": "Status" },
    { "name": "Result" },
]


def check_events(results):
    global errors_events
    for r in results:
        if r[7] != "Completed":
            errors_events = True
        if r[8] == "0" or r[8] == "":
            r[8] = "OK"
        elif r[8] == "4":
            r[8] = "Missed Files"
        elif r[8] == "8":
            r[8] = "Warnings"
        elif r[8] == "12":
            r[8] = "Errors"
        else:
            r[8] = "Failed (%s)"%r[8]
        yield r

try:
    f.output_results(check_events(results), headers)
except pydsm.Failed:
    pass

# ---------------  SUMMARY -------------------

for activity in [ 'BACKUP', 'RESTORE', 'ARCHIVE', 'RETRIEVE', 'STGPOOL BACKUP', 'FULL_DBBACKUP', 'MIGRATION', 'RECLAMATION', 'MOVE DATA' ]:
    header("summary %s"%activity)

    results = d.execute(
    """select
        entity as "Node",
        activity as "Activity",
        date(start_time) as "Start Date",
        time(start_time) as "Start Time",
        date(end_time) as "End Date",
        time(end_time) as "End Time",
        TIMESTAMPDIFF(2,CHAR(end_time-start_time))/60.0 as "Min",
        bytes/1024/1024 as "Total_MiB",
        case
            when TIMESTAMPDIFF(2,CHAR(end_time-start_time)) >0
            then bytes/TIMESTAMPDIFF(2,CHAR(end_time-start_time))/1024.0/1024.0
            else 0
            end as "MiB/Sec",
        case
            when examined >0
            then affected/examined*100
            else 0
            end as "Volatility_%%"
    from summary
    where START_TIME >= %s and START_TIME < %s and activity=%s
    order by START_TIME
    """, (start, stop, activity))

    headers = [
        { "name": "Node", },
        { "name": "Activity", },
        { "name": "Start Date", },
        { "name": "Start Time", },
        { "name": "End Date", },
        { "name": "End Time", },
        { "name": "Minutes",    "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "MiB",        "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "MiB/Sec",    "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "Volatility", "justify": "right", "format": "float", "spec": "%0.1f" },
    ]


    try:
        f.output_results(results, headers)
    except pydsm.Failed:
        pass


# ---------------  ACTLOG -------------------

header("actlog")

results = d.execute(
"""select
    date(DATE_TIME),
    time(DATE_TIME),
    NODENAME,
    MESSAGE
from actlog
where DATE_TIME >= %s and DATE_TIME < %s and ( SEVERITY='E' or SEVERITY='S' ) and (MSGNO!=2034 and MSGNO!=1701 and MSGNO!=944)
order by DATE_TIME
""", (start, stop))

headers = [
    { "name": "Date", },
    { "name": "Time", },
    { "name": "Node", },
    { "name": "Message", },
]


def decode_char(char):
    if char in string.printable:
        return char
    return "%%%02X"%(ord(char))

def decode(string):
    try:
        return string.decode("utf-8")
    except UnicodeDecodeError:
        return "".join(map(decode_char, string))

def check_actlog(results):
    global errors_actlog
    for r in results:
        errors_actlog=True
        m = re.match("(ANE4018E Error processing) '(/nfs/user[12]/[a-z0-9]+/[^/]+/).*(/[^/]+/[^/]*)': (file name too long \(SESSION: [0-9]+\))", r[3])
        if m is not None:
            r[3] =  "%s '%s...%s': %s"%(m.group(1), m.group(2), m.group(3), m.group(4))
        f.write(u"%s, %s, %s, %s" % (decode(r[0]), decode(r[1]), decode(r[2]), decode(r[3])))

try:
    check_actlog(results)
except pydsm.Failed:
    pass

# ---------------  USAGE -------------------

if args.date is None:
    header("usage")

    results = d.execute(
    "SELECT node_name, sum(logical_mb), sum(physical_mb), sum(physical_mb)-sum(logical_mb) FROM occupancy GROUP BY node_name")

    headers = [
        { "name": "Node", },
        { "name": "Logical (MiB)",  "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "Physical (MiB)", "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "Overhead (MiB)", "justify": "right", "format": "float", "spec": "%0.1f" },
    ]
    f.output_results(results, headers)

# ---------------  ERRORS -------------------
header("errors")

needs_attention = False

if errors_events:
    f.write("Errors in events")
    f.write("\n")
    needs_attention = True

if errors_actlog:
    f.write("Errors in activity log")
    f.write("\n")


d.close()

# ---------------  Send E-MAIL -------------------
if args.debug:
    sys.stdout.write(s.getvalue())
    s.close()
else:
    msg=email.mime.text.MIMEText(s.getvalue(), _charset="utf8")
    s.close()

    if needs_attention:
        msg['Subject'] = "TSM Operational Report: Needs Attention"
    else:
        msg['Subject'] = "TSM Operational Report"

    msg['From'] = args.sender
    msg['To'] = args.email

    p = subprocess.Popen(["/usr/sbin/sendmail", "-t"], stdin=subprocess.PIPE)
    p.communicate(msg.as_string())
