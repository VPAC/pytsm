#!/usr/bin/python
import datetime
import pydsm
import argparse
import sys

today = datetime.datetime.now().date()

yesterday = today - datetime.timedelta(1)

start = datetime.datetime.combine(yesterday, datetime.time(8,30))
stop = datetime.datetime.combine(today, datetime.time(8,30))

errors_events=False
errors_actlog=False

def header(name):
    l = len(name)
    sys.stdout.write("\n\n%s\n* %s *\n%s\n"%("*"*(l+4),name.upper(),"*"*(l+4)))

# parse arguments

parser = argparse.ArgumentParser(description='Display TSM backup history')
parser.add_argument('--server', dest="server",
                   help='TSM server to connect to')
parser.add_argument('--format', dest="format",
                   choices=["readable", "csv"], default="readable",
                   help='format to use when displaying results')

args = parser.parse_args()

def message_handler(msg_prefix, msg_number, msg_type, msg_text):
    sys.stdout.write("%s%s%s %s\n"%(msg_prefix, msg_number, msg_type, msg_text))

d = pydsm.dsmadmc()
d.set_message_handler(message_handler)
d.auto_open(args.server)


sys.stdout.write("TSM summary from %s to %s\n\n"%(start,stop))

# ---------------  EVENTS -------------------

header("events")

results = d.execute(
"""select
    date(SCHEDULED_START),
    time(SCHEDULED_START),
    time(ACTUAL_START),
    time(COMPLETED),
    DOMAIN_NAME,
    SCHEDULE_NAME,
    NODE_NAME,
    STATUS,
    RESULT
from events
where SCHEDULED_START >= %s and SCHEDULED_START < %s
order by SCHEDULED_START
""", (start, stop))

headers = [
    { "name": "Date", },
    { "name": "Scheduled", },
    { "name": "Start", },
    { "name": "Completed", },
    { "name": "Domain", },
    { "name": "Schedule", },
    { "name": "Node", },
    { "name": "Status" },
    { "name": "Result" },
]


def check_events(results):
    global errors_events
    for r in results:
        if r[7] != "Completed":
            errors_events = True
        if r[8] == "0" or r[8] == "":
            r[8] = "OK"
        elif r[8] == "4":
            r[8] = "Missed Files"
        elif r[8] == "8":
            r[8] = "Warnings"
        elif r[8] == "12":
            r[8] = "Errors"
        else:
            r[8] = "Failed (%s)"%r[8]
        yield r

try:
    pydsm.output_results(check_events(results), headers, args.format)
except pydsm.Failed:
    pass

# ---------------  SUMMARY -------------------

for activity in [ 'BACKUP', 'RESTORE', 'ARCHIVE', 'RETRIEVE', 'STGPOOL BACKUP', 'FULL_DBBACKUP', 'MIGRATION', 'RECLAMATION', 'MOVE DATA' ]:
    header("summary %s"%activity)

    results = d.execute(
    """select
        entity as "Node",
        activity as "Activity",
        date(start_time) as "Start Date",
        time(start_time) as "Start Time",
        date(end_time) as "End Date",
        time(end_time) as "End Time",
        TIMESTAMPDIFF(2,CHAR(end_time-start_time))/60.0 as "Min",
        bytes/1024/1024 as "Total_MiB",
        case
            when TIMESTAMPDIFF(2,CHAR(end_time-start_time)) >0
            then bytes/TIMESTAMPDIFF(2,CHAR(end_time-start_time))/1024.0/1024.0
            else 0
            end as "MiB/Sec",
        case
            when examined >0
            then affected/examined*100
            else 0
            end as "Volatility_%%"
    from summary
    where START_TIME >= %s and START_TIME < %s and activity=%s
    order by START_TIME
    """, (start, stop, activity))

    headers = [
        { "name": "Node", },
        { "name": "Activity", },
        { "name": "Start Date", },
        { "name": "Start Time", },
        { "name": "End Date", },
        { "name": "End Time", },
        { "name": "Minutes",    "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "MiB",        "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "MiB/Sec",    "justify": "right", "format": "float", "spec": "%0.1f" },
        { "name": "Volatility", "justify": "right", "format": "float", "spec": "%0.1f" },
    ]


    try:
        pydsm.output_results(results, headers, args.format)
    except pydsm.Failed:
        pass


# ---------------  ACTLOG -------------------

header("actlog")

results = d.execute(
"""select
    date(DATE_TIME),
    time(DATE_TIME),
    NODENAME,
    MESSAGE
from actlog
where DATE_TIME >= %s and DATE_TIME < %s and ( SEVERITY='E' or SEVERITY='S' ) and (MSGNO!=2034 and MSGNO!=1701 and MSGNO!=944)
order by DATE_TIME
""", (start, stop))

headers = [
    { "name": "Date", },
    { "name": "Time", },
    { "name": "Node", },
    { "name": "Message", },
]


def check_actlog(results):
    global errors_actlog
    for r in results:
        errors_actlog=True
        yield r

try:
    pydsm.output_results(check_actlog(results), headers, args.format)
except pydsm.Failed:
    pass

# USAGE

header("usage")

results = d.execute(
"SELECT node_name, sum(logical_mb), sum(physical_mb), sum(physical_mb)-sum(logical_mb) FROM occupancy GROUP BY node_name")

headers = [
    { "name": "Node", },
    { "name": "Logical (MiB)",  "justify": "right", "format": "float", "spec": "%0.1f" },
    { "name": "Physical (MiB)", "justify": "right", "format": "float", "spec": "%0.1f" },
    { "name": "Overhead (MiB)", "justify": "right", "format": "float", "spec": "%0.1f" },
]
pydsm.output_results(results, headers, args.format)

# ---------------  ERRORS -------------------
header("errors")

if errors_events:
    sys.stdout.write("Errors in events")
    sys.stdout.write("\n")

if errors_actlog:
    sys.stdout.write("Errors in activity log")
    sys.stdout.write("\n")


d.close()
